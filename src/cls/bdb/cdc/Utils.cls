/// <b>Experimental!</b>
/// <p>This class helps users implement a Change Data Capture strategy that leverages Mirroring to
/// track changes to one or more tables without any impact to the source system. It requires that an
/// async reporting member is created to track the primary instance, on which a dejournaling filter
/// will then use ^OBJ.DSTIME to log any changes, from where they can be consumed through mechanisms
/// such as <class>%DeepSee.TimeSync</class>.
/// <p>The <method>GenerateDSTIME</method> builds a <class>SYS.MirrorDejournal</class> that will track any
/// updates to master maps of the set of tables identified in this table's extent. For those tables,
/// any SET or KILL operations to their primary data global encountered in a journal file will cause
/// an ^OBJ.DSTIME record to be written for consumption on the async member.</p>
Class bdb.cdc.Utils Extends %Persistent
{

Property namespace As %String [ InitialExpression = {$namespace} ];

Property tableName As %String;

ClassMethod GenerateDSTIME(dejournalFilterClassName As %String = "bdb.cdc.ZFilter", glorefType As %String(VALUELIST=",plain,namespace") = "plain", verbose As %Boolean = 1) As %Status
{
    new $namespace
    set sc = $$$OK, originalNamespace = $namespace
    try {

        set rsClasses = ##class(%SQL.Statement).%ExecDirect(,"SELECT * FROM bdb_cdc.Utils ORDER BY namespace, tableName")
        while rsClasses.%Next() {

            set ns = rsClasses.%Get("namespace"), t = rsClasses.%Get("tableName")
            if ns'=$namespace {
                set $namespace = ns
            }

            if '$SYSTEM.SQL.Schema.TableExists(t, .metadata) {
                do Log("ERROR","Could not find table '"_t_"' in namespace '"_ns_"', skipping")
                continue
            }
            set cls = $lg(metadata,3)

            // try to find main storage global in storage def
            set sname = ##class(%Dictionary.CompiledClass).%OpenId(cls).StorageStrategy
            set sdef = ##class(%Dictionary.CompiledStorage).%OpenId(cls_"||"_sname)
            set masterMap = sdef.DataLocation
            if (masterMap="") || '$zname($e(masterMap,2,*)  ,3) {
                do Log("WARNING", "Storage definition for table '"_t_"' in namespace '"_ns_"' has invalid DataLocation: "_masterMap)
                continue // could try to revert to extent mgr
            }
            if sdef.SqlRowIdProperty'="%%ID" {
                do Log("WARNING", "Storage definition for table '"_t_"' in namespace '"_ns_"' has nonstandard ROWID, generated code may not work")
            }

            do Log("INFO", "Using "_masterMap_" as main data location for table '"_t_"' in namespace '"_ns_"'")

            set map(ns, masterMap, cls) = ""
            
        }

        // dejournal filter class needs to be written in %SYS
        zn "%SYS"

        set code = 0
        do Code("   quit:(RecordType'=""S"")&&(RecordType'=""K"") 1")
        do Code("   set g = $p(GlobalReference,""("",1), id = $replace($e($p(GlobalReference,""("",*),1,*-1),"","",""||""), now=+$g(^OBJ.DSTIME)")

        set ns = "", ref = ""
        for {
            set ns = $order(map(ns))
            quit:ns=""
            
            if $$$LOWER(glorefType)="namespace" {
                set ref="["""_ns_"""]"
            }

            do Code("")
            do Code("   // Namespace: "_ns)
            set global = ""
            for {
                set global = $order(map(ns,global))
                quit:global=""

                do Code("   if (g="""_$e(global,2,*)_""") {")
                set cls = ""
                for {
                    set cls = $order(map(ns,global,cls))
                    quit:cls=""
                    do Code("       set ^"_ref_"OBJ.DSTIME("""_cls_""",now,id)=$s(RecordType=""K"":2, $d(@GlobalReference):0, 1:1)")
                }
                do Code("   }")
            }
        }
        do Code("   quit 1")

        // if we got this far, let's write the class
        if $$$defClassDefined(dejournalFilterClassName) {
            set sc = $$Delete^%apiOBJ(dejournalFilterClassName, "-d")
        }

        set class = ##class(%Dictionary.ClassDefinition).%New()
        set class.Name = dejournalFilterClassName
        set class.Super = "SYS.MirrorDejournal"
        set class.ProcedureBlock = 1
        set class.Description = "Class generated by <class>"_$CLASSNAME()_"</class> for pushing dejournaled records into ^OBJ.DSTIME"
        
        set method = ##class(%Dictionary.MethodDefinition).%New()
        set method.parent = class
        set method.Name = "RunFilter"
        set method.FormalSpec = "MirrorDBName:%String,GlobalReference:%String,RecordType:%String,Address:%Integer"
        set method.ReturnType = "%Integer"

        for i = 1:1:code {
            do method.Implementation.WriteLine(code(i))
        }

        set sc = class.%Save()
        quit:$$$ISERR(sc)

        set sc = $system.OBJ.Compile(dejournalFilterClassName,$s(verbose:"d",1:"-d"))
        quit:$$$ISERR(sc)

    } catch (ex) {
        set sc = ex.AsStatus()
    }
    
    quit sc

Log(level, message)
    write:verbose !,$zdt($h)," - ",level,": ",message
    quit
Code(line)
    set code=$g(code)+1, code(code)=line
}

Storage Default
{
<Data name="UtilsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>namespace</Value>
</Value>
<Value name="3">
<Value>tableName</Value>
</Value>
</Data>
<DataLocation>^bdb.cdc.UtilsD</DataLocation>
<DefaultData>UtilsDefaultData</DefaultData>
<ExtentSize>100</ExtentSize>
<IdLocation>^bdb.cdc.UtilsD</IdLocation>
<IndexLocation>^bdb.cdc.UtilsI</IndexLocation>
<StreamLocation>^bdb.cdc.UtilsS</StreamLocation>
<Type>%Storage.Persistent</Type>
}

}
